// Copyright (C) 2025 io finnet group, inc.
// SPDX-License-Identifier: AGPL-3.0-or-later
// Full license text available in LICENSE file in repository root.

package hd

import (
	"encoding/hex"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Test vectors generated by tss-lib using:
// cd tss && go test -v -run TestGenerateHDVectors ./mobile/tss/
//
// These tests verify that our HD derivation produces the same results as tss-lib

// TestDerivationMatchesTSS_ECDSA_Secp256k1 verifies our HD derivation matches tss-lib
// using BIP32 Test Vector 1
func TestDerivationMatchesTSS_ECDSA_Secp256k1(t *testing.T) {
	// BIP32 Test Vector 1 - master private key from seed 000102030405060708090a0b0c0d0e0f
	masterSKHex := "e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35"
	chainCodeHex := "873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508"

	masterSK, _ := hex.DecodeString(masterSKHex)
	chainCode, _ := hex.DecodeString(chainCodeHex)

	// Test vectors generated by tss-lib
	testCases := []struct {
		path           string
		expectedChildSK string
		expectedChildPK string
	}{
		{
			path:           "m/0",
			expectedChildSK: "4e2cdcf2f14e802810e878cf9e6411fc4e712edf19a06bcfcc5d5572e489a3b7",
			expectedChildPK: "027c4b09ffb985c298afe7e5813266cbfcb7780b480ac294b0b43dc21f2be3d13c",
		},
		{
			path:           "m/44/0/0",
			expectedChildSK: "c95ea3f7d9e32d8356eb630d77ede8c1e8a7578ed0b61ec9c4915b0dca96c217",
			expectedChildPK: "02b41ee4dfdf05264b0eaad3c8e271b973ff225e1e81ab0585b23cad4de0c4a1e6",
		},
		{
			path:           "m/44/60/0/0/0",
			expectedChildSK: "70d32e0e32025fdf1f41cafbe3ae21d78134e9f3a639c4a889336eb4b2b4a605",
			expectedChildPK: "0389988f76588819d77d0a639a962fee68e94441878d01121d65c602f28d5e17a4",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.path, func(t *testing.T) {
			// Compute parent public key
			parentPubKey, err := computePublicKey(masterSK, AlgorithmECDSA, CurveSecp256k1)
			require.NoError(t, err)

			// Parse path
			indices, err := ParseDerivationPath(tc.path)
			require.NoError(t, err)

			// Derive child key
			actualChildSK, actualChildPK, err := deriveChildKey(masterSK, chainCode, parentPubKey, indices, AlgorithmECDSA, CurveSecp256k1)
			require.NoError(t, err)

			// Compare results
			assert.Equal(t, tc.expectedChildSK, hex.EncodeToString(actualChildSK),
				"Child private key should match tss-lib derivation")
			assert.Equal(t, tc.expectedChildPK, hex.EncodeToString(actualChildPK),
				"Child public key should match tss-lib derivation")

			t.Logf("Path %s: SK=%s PK=%s", tc.path, hex.EncodeToString(actualChildSK), hex.EncodeToString(actualChildPK))
		})
	}
}

// TestDerivationMatchesTSS_EdDSA_Edwards25519 verifies EdDSA derivation matches tss-lib
func TestDerivationMatchesTSS_EdDSA_Edwards25519(t *testing.T) {
	// Test vectors from tss-lib
	masterSKHex := "9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60"
	chainCodeHex := "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"

	masterSK, _ := hex.DecodeString(masterSKHex)
	chainCode, _ := hex.DecodeString(chainCodeHex)

	// Test vectors generated by tss-lib
	testCases := []struct {
		path           string
		expectedChildSK string
		expectedChildPK string
	}{
		{
			path:           "m/0",
			expectedChildSK: "0a4f1b3e9c9b6703326323221740da1c9b6c315f212837ba6c3435edfdd7c295",
			expectedChildPK: "f0668f57fe91dd5ef7c83ef38754831e37116aedcaaaeb248e3c90005e6ea51c",
		},
		{
			path:           "m/44/501/0/0",
			expectedChildSK: "0cb845b159035c3285e5a08fc2980221270745affc74e952d71764da41240722",
			expectedChildPK: "9531744deb5d0128ad55a3bc544dc89e6bf6e2ea359f56eaae604fc4eb2536ff",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.path, func(t *testing.T) {
			// Compute parent public key
			parentPubKey, err := computePublicKey(masterSK, AlgorithmEDDSA, CurveEdwards25519)
			require.NoError(t, err)

			// Parse path
			indices, err := ParseDerivationPath(tc.path)
			require.NoError(t, err)

			// Derive child key
			actualChildSK, actualChildPK, err := deriveChildKey(masterSK, chainCode, parentPubKey, indices, AlgorithmEDDSA, CurveEdwards25519)
			require.NoError(t, err)

			// Compare results
			assert.Equal(t, tc.expectedChildSK, hex.EncodeToString(actualChildSK),
				"Child private key should match tss-lib derivation")
			assert.Equal(t, tc.expectedChildPK, hex.EncodeToString(actualChildPK),
				"Child public key should match tss-lib derivation")

			t.Logf("Path %s: SK=%s PK=%s", tc.path, hex.EncodeToString(actualChildSK), hex.EncodeToString(actualChildPK))
		})
	}
}

// TestDerivationMatchesTSS_Schnorr_Secp256k1 verifies Schnorr derivation matches tss-lib
func TestDerivationMatchesTSS_Schnorr_Secp256k1(t *testing.T) {
	// Same master key as ECDSA (Schnorr uses secp256k1)
	masterSKHex := "e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35"
	chainCodeHex := "873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508"

	masterSK, _ := hex.DecodeString(masterSKHex)
	chainCode, _ := hex.DecodeString(chainCodeHex)

	// Test vector from tss-lib
	testCases := []struct {
		path           string
		expectedChildSK string
		expectedChildPK string
	}{
		{
			path:           "m/86/0/0/0/0",
			expectedChildSK: "989ad7fcd714e2ffed41e287422e96e39df6225e4145bc45dc0cbc024c4641fb",
			expectedChildPK: "0258387941128a0f18720ff2ba08416015dca2603a86a9a62b98dfbc1130b291e7",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.path, func(t *testing.T) {
			// Compute parent public key
			parentPubKey, err := computePublicKey(masterSK, AlgorithmSCHNORR, CurveSecp256k1)
			require.NoError(t, err)

			// Parse path
			indices, err := ParseDerivationPath(tc.path)
			require.NoError(t, err)

			// Derive child key
			actualChildSK, actualChildPK, err := deriveChildKey(masterSK, chainCode, parentPubKey, indices, AlgorithmSCHNORR, CurveSecp256k1)
			require.NoError(t, err)

			// Compare results
			assert.Equal(t, tc.expectedChildSK, hex.EncodeToString(actualChildSK),
				"Child private key should match tss-lib derivation")
			assert.Equal(t, tc.expectedChildPK, hex.EncodeToString(actualChildPK),
				"Child public key should match tss-lib derivation")

			t.Logf("Path %s: SK=%s PK=%s", tc.path, hex.EncodeToString(actualChildSK), hex.EncodeToString(actualChildPK))
		})
	}
}

// TestDerivationMatchesTSS_ECDSA_P256 verifies P-256 derivation matches tss-lib
func TestDerivationMatchesTSS_ECDSA_P256(t *testing.T) {
	// Same master key as ECDSA secp256k1
	masterSKHex := "e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35"
	chainCodeHex := "873dff81c02f525623fd1fe5167eac3a55a049de3d314bb42ee227ffed37d508"

	masterSK, _ := hex.DecodeString(masterSKHex)
	chainCode, _ := hex.DecodeString(chainCodeHex)

	// Test vector from tss-lib
	testCases := []struct {
		path           string
		expectedChildSK string
		expectedChildPK string
	}{
		{
			path:           "m/0",
			expectedChildSK: "aa99fd5bdbefd92f802f278e0c8998ac0408b8afab8a77e695dcb9dc3addcc81",
			expectedChildPK: "02d3cbd426c052a03c9027eafcb4b13873163ad24680b0cc58c76d3762fbc6cebf",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.path, func(t *testing.T) {
			// Compute parent public key
			parentPubKey, err := computePublicKey(masterSK, AlgorithmECDSA, CurveP256)
			require.NoError(t, err)

			// Parse path
			indices, err := ParseDerivationPath(tc.path)
			require.NoError(t, err)

			// Derive child key
			actualChildSK, actualChildPK, err := deriveChildKey(masterSK, chainCode, parentPubKey, indices, AlgorithmECDSA, CurveP256)
			require.NoError(t, err)

			// Compare results
			assert.Equal(t, tc.expectedChildSK, hex.EncodeToString(actualChildSK),
				"Child private key should match tss-lib derivation")
			assert.Equal(t, tc.expectedChildPK, hex.EncodeToString(actualChildPK),
				"Child public key should match tss-lib derivation")

			t.Logf("Path %s: SK=%s PK=%s", tc.path, hex.EncodeToString(actualChildSK), hex.EncodeToString(actualChildPK))
		})
	}
}
